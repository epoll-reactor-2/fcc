/* Storage.hpp - Variable pool.
 * Copyright (C) 2022 epoll-reactor <glibcxx.chrono@gmail.com>
 *
 * This file is distributed under the MIT license.
 */

#ifndef WEAK_COMPILER_MIDDLE_END_SYMBOLS_STORAGE_HPP
#define WEAK_COMPILER_MIDDLE_END_SYMBOLS_STORAGE_HPP

#include "FrontEnd/Lex/Token.hpp"
#include <map>

namespace weak {
namespace middleEnd {

/*!
 * Storage for instructions and literals, used by IR only.
 *
 * Note that this class is designed to be friend with CodeGen to access
 * API for forwarding instructions into it.
 */
class Storage {
private:
  /// Actually a variable description.
  struct Record {
    /// Scope depth, starts with 0.
    unsigned Depth;

    /// Identifier, generated by lexical analyzer, used to lookup and set
    /// operations.
    unsigned Attribute;

    /// This is used by IR generator.
    unsigned TemporaryLabel;

    /// The name of variable.
    std::string Name;

    /// Data type of stored variable, used for type checking.
    frontEnd::TokenType DataType;
  };

  using RecordMap = std::map</*Attribute=*/unsigned, Record>;

public:
  /// Open new scope.
  void ScopeBegin();

  /// Terminate scope and destroy all variables, presented inside it.
  void ScopeEnd();

  /// Add record to table without specifying any information about type,
  /// value etc.
  unsigned AddSymbol(std::string_view Name);

  /// Specify variable type.
  void SetSymbolType(unsigned Attribute, frontEnd::TokenType Type);

  unsigned TotalVariables() { return Records.size(); }

private:
  friend class CodeGen;

  Record *GetSymbol(unsigned Attribute);
  Record *GetByName(std::string_view Name);

  unsigned CurrentScopeDepth{0U};
  unsigned CurrentAttribute{0U};
  RecordMap Records;
};

} // namespace middleEnd
} // namespace weak

#endif // WEAK_COMPILER_MIDDLE_END_SYMBOLS_STORAGE_HPP
